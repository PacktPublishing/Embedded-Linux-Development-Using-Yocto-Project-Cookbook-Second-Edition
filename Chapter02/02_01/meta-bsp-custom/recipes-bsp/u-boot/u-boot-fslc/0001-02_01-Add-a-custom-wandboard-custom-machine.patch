From 74589d3616a107a80a1e9782b0a7e933bfb50744 Mon Sep 17 00:00:00 2001
From: Alex Gonzalez <alex.gonzalez@digi.com>
Date: Tue, 15 Aug 2017 19:21:16 +0200
Subject: [PATCH] 02_01: Add a custom wandboard-custom machine.

Signed-off-by: Alex Gonzalez <alex.gonzalez@digi.com>
---
 arch/arm/mach-imx/mx6/Kconfig             |   6 +
 board/wandboard-custom/Kconfig            |   9 +
 board/wandboard-custom/MAINTAINERS        |   6 +
 board/wandboard-custom/Makefile           |   7 +
 board/wandboard-custom/README             |  41 +++
 board/wandboard-custom/spl.c              | 425 ++++++++++++++++++++++
 board/wandboard-custom/wandboard-custom.c | 561 ++++++++++++++++++++++++++++++
 configs/wandboard-custom_defconfig        |  40 +++
 include/configs/wandboard-custom.h        | 169 +++++++++
 9 files changed, 1264 insertions(+)
 create mode 100644 board/wandboard-custom/Kconfig
 create mode 100644 board/wandboard-custom/MAINTAINERS
 create mode 100644 board/wandboard-custom/Makefile
 create mode 100644 board/wandboard-custom/README
 create mode 100644 board/wandboard-custom/spl.c
 create mode 100644 board/wandboard-custom/wandboard-custom.c
 create mode 100644 configs/wandboard-custom_defconfig
 create mode 100644 include/configs/wandboard-custom.h

diff --git a/arch/arm/mach-imx/mx6/Kconfig b/arch/arm/mach-imx/mx6/Kconfig
index b82db3af22f6..bb88ff1f35f0 100644
--- a/arch/arm/mach-imx/mx6/Kconfig
+++ b/arch/arm/mach-imx/mx6/Kconfig
@@ -395,6 +395,11 @@ config TARGET_WANDBOARD
 	select BOARD_LATE_INIT
 	select SUPPORT_SPL
 
+config TARGET_WANDBOARD_CUSTOM
+	bool "wandboard-custom"
+	select BOARD_LATE_INIT
+	select SUPPORT_SPL
+
 config TARGET_WARP
 	bool "WaRP"
 	select BOARD_LATE_INIT
@@ -471,6 +476,7 @@ source "board/toradex/colibri_imx6/Kconfig"
 source "board/udoo/Kconfig"
 source "board/udoo/neo/Kconfig"
 source "board/wandboard/Kconfig"
+source "board/wandboard-custom/Kconfig"
 source "board/warp/Kconfig"
 
 endif
diff --git a/board/wandboard-custom/Kconfig b/board/wandboard-custom/Kconfig
new file mode 100644
index 000000000000..92889ea045c5
--- /dev/null
+++ b/board/wandboard-custom/Kconfig
@@ -0,0 +1,9 @@
+if TARGET_WANDBOARD_CUSTOM
+
+config SYS_BOARD
+	default "wandboard-custom"
+
+config SYS_CONFIG_NAME
+	default "wandboard-custom"
+
+endif
diff --git a/board/wandboard-custom/MAINTAINERS b/board/wandboard-custom/MAINTAINERS
new file mode 100644
index 000000000000..86dbefe4e0a4
--- /dev/null
+++ b/board/wandboard-custom/MAINTAINERS
@@ -0,0 +1,6 @@
+WANDBOARD BOARD
+M:	Alex Gonzalez <alex@lindusembedded.com>
+S:	Maintained
+F:	board/wandboard-custom/
+F:	include/configs/wandboard-custom.h
+F:	configs/wandboard-custom_defconfig
diff --git a/board/wandboard-custom/Makefile b/board/wandboard-custom/Makefile
new file mode 100644
index 000000000000..b80b90d2d6f3
--- /dev/null
+++ b/board/wandboard-custom/Makefile
@@ -0,0 +1,7 @@
+#
+# (C) Copyright 2013 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := wandboard-custom.o spl.o
diff --git a/board/wandboard-custom/README b/board/wandboard-custom/README
new file mode 100644
index 000000000000..05da2e739b32
--- /dev/null
+++ b/board/wandboard-custom/README
@@ -0,0 +1,41 @@
+U-Boot for Wandboard Custom
+---------------------------
+
+This file contains information for the port of U-Boot to the Wandboard Custom.
+
+This is an example to add a new machine based on the Wandboard.
+
+Wandboard is a development board that has three variants based on the following
+SoCs: mx6 quad, mx6 dual lite and mx6 solo.
+
+For more details about Wandboard, please refer to:
+http://www.wandboard.org/
+
+Building U-Boot for Wandboard Custom
+------------------------------------
+
+To build U-Boot for the Wandboard:
+
+$ make wandboard-custom_config
+$ make
+
+Flashing U-Boot into the SD card
+--------------------------------
+
+- After the 'make' command completes, the generated 'SPL' binary must be
+flashed into the SD card;
+
+$ sudo dd if=SPL of=/dev/mmcblk0 bs=1k seek=1; sync
+
+(Note - the SD card node may vary, so adjust this as needed).
+
+- Flash the u-boot.img image into the SD card:
+
+sudo dd if=u-boot.img of=/dev/mmcblk0 bs=1k seek=69; sync
+
+- Insert the SD card into the slot located in the bottom of the board (same side
+as the mx6 processor)
+
+- Connect the serial cable to the host PC
+
+- Power up the board and U-Boot messages will appear in the serial console.
diff --git a/board/wandboard-custom/spl.c b/board/wandboard-custom/spl.c
new file mode 100644
index 000000000000..d6f568bb9261
--- /dev/null
+++ b/board/wandboard-custom/spl.c
@@ -0,0 +1,425 @@
+/*
+ * Copyright (C) 2014 Wandboard
+ * Author: Tungyi Lin <tungyilin1127@gmail.com>
+ *         Richard Hu <hakahu@gmail.com>
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/video.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <spl.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if defined(CONFIG_SPL_BUILD)
+#include <asm/arch/mx6-ddr.h>
+/*
+ * Driving strength:
+ *   0x30 == 40 Ohm
+ *   0x28 == 48 Ohm
+ */
+
+#define IMX6DQ_DRIVE_STRENGTH		0x30
+#define IMX6SDL_DRIVE_STRENGTH		0x28
+#define IMX6QP_DRIVE_STRENGTH		0x28
+
+/* configure MX6Q/DUAL mmdc DDR io registers */
+static struct mx6dq_iomux_ddr_regs mx6dq_ddr_ioregs = {
+	.dram_sdclk_0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdclk_1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_cas = IMX6DQ_DRIVE_STRENGTH,
+	.dram_ras = IMX6DQ_DRIVE_STRENGTH,
+	.dram_reset = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdcke0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdcke1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdodt1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs2 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs3 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs4 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs5 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs6 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs7 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm2 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm3 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm4 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm5 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm6 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm7 = IMX6DQ_DRIVE_STRENGTH,
+};
+
+/* configure MX6QP mmdc DDR io registers */
+static struct mx6dq_iomux_ddr_regs mx6qp_ddr_ioregs = {
+	.dram_sdclk_0 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdclk_1 = IMX6QP_DRIVE_STRENGTH,
+	.dram_cas = IMX6QP_DRIVE_STRENGTH,
+	.dram_ras = IMX6QP_DRIVE_STRENGTH,
+	.dram_reset = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdcke0 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdcke1 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdodt1 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdqs0 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdqs1 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdqs2 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdqs3 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdqs4 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdqs5 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdqs6 = IMX6QP_DRIVE_STRENGTH,
+	.dram_sdqs7 = IMX6QP_DRIVE_STRENGTH,
+	.dram_dqm0 = IMX6QP_DRIVE_STRENGTH,
+	.dram_dqm1 = IMX6QP_DRIVE_STRENGTH,
+	.dram_dqm2 = IMX6QP_DRIVE_STRENGTH,
+	.dram_dqm3 = IMX6QP_DRIVE_STRENGTH,
+	.dram_dqm4 = IMX6QP_DRIVE_STRENGTH,
+	.dram_dqm5 = IMX6QP_DRIVE_STRENGTH,
+	.dram_dqm6 = IMX6QP_DRIVE_STRENGTH,
+	.dram_dqm7 = IMX6QP_DRIVE_STRENGTH,
+};
+
+/* configure MX6Q/DUAL mmdc GRP io registers */
+static struct mx6dq_iomux_grp_regs mx6dq_grp_ioregs = {
+	.grp_ddr_type = 0x000c0000,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_addds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_ctlds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_ddrmode = 0x00020000,
+	.grp_b0ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b1ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b2ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b3ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b4ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b5ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b6ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b7ds = IMX6DQ_DRIVE_STRENGTH,
+};
+
+/* configure MX6QP mmdc GRP io registers */
+static struct mx6dq_iomux_grp_regs mx6qp_grp_ioregs = {
+	.grp_ddr_type = 0x000c0000,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_addds = IMX6QP_DRIVE_STRENGTH,
+	.grp_ctlds = IMX6QP_DRIVE_STRENGTH,
+	.grp_ddrmode = 0x00020000,
+	.grp_b0ds = IMX6QP_DRIVE_STRENGTH,
+	.grp_b1ds = IMX6QP_DRIVE_STRENGTH,
+	.grp_b2ds = IMX6QP_DRIVE_STRENGTH,
+	.grp_b3ds = IMX6QP_DRIVE_STRENGTH,
+	.grp_b4ds = IMX6QP_DRIVE_STRENGTH,
+	.grp_b5ds = IMX6QP_DRIVE_STRENGTH,
+	.grp_b6ds = IMX6QP_DRIVE_STRENGTH,
+	.grp_b7ds = IMX6QP_DRIVE_STRENGTH,
+};
+
+/* configure MX6SOLO/DUALLITE mmdc DDR io registers */
+struct mx6sdl_iomux_ddr_regs mx6sdl_ddr_ioregs = {
+	.dram_sdclk_0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdclk_1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_cas = IMX6SDL_DRIVE_STRENGTH,
+	.dram_ras = IMX6SDL_DRIVE_STRENGTH,
+	.dram_reset = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdcke0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdcke1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdodt1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs2 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs3 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs4 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs5 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs6 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs7 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm2 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm3 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm4 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm5 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm6 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm7 = IMX6SDL_DRIVE_STRENGTH,
+};
+
+/* configure MX6SOLO/DUALLITE mmdc GRP io registers */
+struct mx6sdl_iomux_grp_regs mx6sdl_grp_ioregs = {
+	.grp_ddr_type = 0x000c0000,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_addds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_ctlds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_ddrmode = 0x00020000,
+	.grp_b0ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b1ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b2ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b3ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b4ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b5ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b6ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b7ds = IMX6SDL_DRIVE_STRENGTH,
+};
+
+/* H5T04G63AFR-PB */
+static struct mx6_ddr3_cfg h5t04g63afr = {
+	.mem_speed = 1600,
+	.density = 4,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 15,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+};
+
+/* H5TQ2G63DFR-H9 */
+static struct mx6_ddr3_cfg h5tq2g63dfr = {
+	.mem_speed = 1333,
+	.density = 2,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 14,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1350,
+	.trcmin = 4950,
+	.trasmin = 3600,
+};
+
+static struct mx6_mmdc_calibration mx6q_2g_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x001f001f,
+	.p0_mpwldectrl1 = 0x001f001f,
+	.p1_mpwldectrl0 = 0x001f001f,
+	.p1_mpwldectrl1 = 0x001f001f,
+	.p0_mpdgctrl0 = 0x4301030d,
+	.p0_mpdgctrl1 = 0x03020277,
+	.p1_mpdgctrl0 = 0x4300030a,
+	.p1_mpdgctrl1 = 0x02780248,
+	.p0_mprddlctl = 0x4536393b,
+	.p1_mprddlctl = 0x36353441,
+	.p0_mpwrdlctl = 0x41414743,
+	.p1_mpwrdlctl = 0x462f453f,
+};
+
+/* DDR 64bit 2GB */
+static struct mx6_ddr_sysinfo mem_q = {
+	.dsize		= 2,
+	.cs1_mirror	= 0,
+	/* config for full 4GB range so that get_mem_size() works */
+	.cs_density	= 32,
+	.ncs		= 1,
+	.bi_on		= 1,
+	.rtt_nom	= 1,
+	.rtt_wr		= 0,
+	.ralat		= 5,
+	.walat		= 0,
+	.mif3_mode	= 3,
+	.rst_to_cke	= 0x23,
+	.sde_to_rst	= 0x10,
+	.refsel = 1,	/* Refresh cycles at 32KHz */
+	.refr = 3,	/* 4 refresh commands per refresh cycle */
+};
+
+static struct mx6_mmdc_calibration mx6dl_1g_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x001f001f,
+	.p0_mpwldectrl1 = 0x001f001f,
+	.p1_mpwldectrl0 = 0x001f001f,
+	.p1_mpwldectrl1 = 0x001f001f,
+	.p0_mpdgctrl0 = 0x420e020e,
+	.p0_mpdgctrl1 = 0x02000200,
+	.p1_mpdgctrl0 = 0x42020202,
+	.p1_mpdgctrl1 = 0x01720172,
+	.p0_mprddlctl = 0x494c4f4c,
+	.p1_mprddlctl = 0x4a4c4c49,
+	.p0_mpwrdlctl = 0x3f3f3133,
+	.p1_mpwrdlctl = 0x39373f2e,
+};
+
+static struct mx6_mmdc_calibration mx6s_512m_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x0040003c,
+	.p0_mpwldectrl1 = 0x0032003e,
+	.p0_mpdgctrl0 = 0x42350231,
+	.p0_mpdgctrl1 = 0x021a0218,
+	.p0_mprddlctl = 0x4b4b4e49,
+	.p0_mpwrdlctl = 0x3f3f3035,
+};
+
+/* DDR 64bit 1GB */
+static struct mx6_ddr_sysinfo mem_dl = {
+	.dsize		= 2,
+	.cs1_mirror	= 0,
+	/* config for full 4GB range so that get_mem_size() works */
+	.cs_density	= 32,
+	.ncs		= 1,
+	.bi_on		= 1,
+	.rtt_nom	= 1,
+	.rtt_wr		= 0,
+	.ralat		= 5,
+	.walat		= 0,
+	.mif3_mode	= 3,
+	.rst_to_cke	= 0x23,
+	.sde_to_rst	= 0x10,
+	.refsel = 1,	/* Refresh cycles at 32KHz */
+	.refr = 3,	/* 4 refresh commands per refresh cycle */
+};
+
+/* DDR 32bit 512MB */
+static struct mx6_ddr_sysinfo mem_s = {
+	.dsize		= 1,
+	.cs1_mirror	= 0,
+	/* config for full 4GB range so that get_mem_size() works */
+	.cs_density	= 32,
+	.ncs		= 1,
+	.bi_on		= 1,
+	.rtt_nom	= 1,
+	.rtt_wr		= 0,
+	.ralat		= 5,
+	.walat		= 0,
+	.mif3_mode	= 3,
+	.rst_to_cke	= 0x23,
+	.sde_to_rst	= 0x10,
+	.refsel = 1,	/* Refresh cycles at 32KHz */
+	.refr = 3,	/* 4 refresh commands per refresh cycle */
+};
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0x00C03F3F, &ccm->CCGR0);
+	writel(0x0030FC03, &ccm->CCGR1);
+	writel(0x0FFFC000, &ccm->CCGR2);
+	writel(0x3FF03000, &ccm->CCGR3);
+	writel(0x00FFF300, &ccm->CCGR4);
+	writel(0x0F0000C3, &ccm->CCGR5);
+	writel(0x000003FF, &ccm->CCGR6);
+}
+
+static void spl_dram_init_imx6qp_lpddr3(void)
+{
+	/* MMDC0_MDSCR set the Configuration request bit during MMDC set up */
+	writel(0x00008000, MMDC_P0_BASE_ADDR + 0x01c);
+	/* Calibrations - ZQ */
+	writel(0xa1390003, MMDC_P0_BASE_ADDR + 0x800);
+	/* write leveling */
+	writel(0x00060004, MMDC_P0_BASE_ADDR + 0x80c);
+	writel(0x000B0004, MMDC_P0_BASE_ADDR + 0x810);
+	writel(0x00000004, MMDC_P1_BASE_ADDR + 0x80c);
+	writel(0x00000000, MMDC_P1_BASE_ADDR + 0x810);
+	/*
+	 * DQS gating, read delay, write delay calibration values
+	 * based on calibration compare of 0x00ffff00
+	 */
+	writel(0x03040314, MMDC_P0_BASE_ADDR + 0x83c);
+	writel(0x03080300, MMDC_P0_BASE_ADDR + 0x840);
+	writel(0x03000310, MMDC_P1_BASE_ADDR + 0x83c);
+	writel(0x0268023C, MMDC_P1_BASE_ADDR + 0x840);
+	writel(0x4034363A, MMDC_P0_BASE_ADDR + 0x848);
+	writel(0x36302C3C, MMDC_P1_BASE_ADDR + 0x848);
+	writel(0x3E3E4046, MMDC_P0_BASE_ADDR + 0x850);
+	writel(0x483A4844, MMDC_P1_BASE_ADDR + 0x850);
+	writel(0x33333333, MMDC_P0_BASE_ADDR + 0x81c);
+	writel(0x33333333, MMDC_P0_BASE_ADDR + 0x820);
+	writel(0x33333333, MMDC_P0_BASE_ADDR + 0x824);
+	writel(0x33333333, MMDC_P0_BASE_ADDR + 0x828);
+	writel(0x33333333, MMDC_P1_BASE_ADDR + 0x81c);
+	writel(0x33333333, MMDC_P1_BASE_ADDR + 0x820);
+	writel(0x33333333, MMDC_P1_BASE_ADDR + 0x824);
+	writel(0x33333333, MMDC_P1_BASE_ADDR + 0x828);
+	writel(0x24912489, MMDC_P0_BASE_ADDR + 0x8c0);
+	writel(0x24914452, MMDC_P1_BASE_ADDR + 0x8c0);
+	writel(0x00000800, MMDC_P0_BASE_ADDR + 0x8b8);
+	writel(0x00000800, MMDC_P1_BASE_ADDR + 0x8b8);
+	/* MMDC init: in DDR3, 64-bit mode, only MMDC0 is initiated */
+	writel(0x00020036, MMDC_P0_BASE_ADDR + 0x004);
+	writel(0x09444040, MMDC_P0_BASE_ADDR + 0x008);
+	writel(0x898E79A4, MMDC_P0_BASE_ADDR + 0x00c);
+	writel(0xDB538F64, MMDC_P0_BASE_ADDR + 0x010);
+	writel(0x01FF00DD, MMDC_P0_BASE_ADDR + 0x014);
+	writel(0x00011740, MMDC_P0_BASE_ADDR + 0x018);
+	writel(0x00008000, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x000026D2, MMDC_P0_BASE_ADDR + 0x02c);
+	writel(0x008E1023, MMDC_P0_BASE_ADDR + 0x030);
+	writel(0x00000047, MMDC_P0_BASE_ADDR + 0x040);
+	writel(0x14420000, MMDC_P0_BASE_ADDR + 0x400);
+	writel(0x841A0000, MMDC_P0_BASE_ADDR + 0x000);
+	writel(0x00400c58, MMDC_P0_BASE_ADDR + 0x890);
+	/* add NOC DDR configuration */
+	writel(0x00000000, NOC_DDR_BASE_ADDR + 0x008);
+	writel(0x2871C39B, NOC_DDR_BASE_ADDR + 0x00c);
+	writel(0x000005B4, NOC_DDR_BASE_ADDR + 0x038);
+	writel(0x00000040, NOC_DDR_BASE_ADDR + 0x014);
+	writel(0x00000020, NOC_DDR_BASE_ADDR + 0x028);
+	writel(0x00000020, NOC_DDR_BASE_ADDR + 0x02c);
+	writel(0x02088032, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x00008033, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x00048031, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x19308030, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x04008040, MMDC_P0_BASE_ADDR + 0x01c);
+	writel(0x00007800, MMDC_P0_BASE_ADDR + 0x020);
+	writel(0x00022227, MMDC_P0_BASE_ADDR + 0x818);
+	writel(0x00022227, MMDC_P1_BASE_ADDR + 0x818);
+	writel(0x00025576, MMDC_P0_BASE_ADDR + 0x004);
+	writel(0x00011006, MMDC_P0_BASE_ADDR + 0x404);
+	writel(0x00000000, MMDC_P0_BASE_ADDR + 0x01c);
+}
+
+static void spl_dram_init(void)
+{
+	if (is_mx6dqp()) {
+		mx6dq_dram_iocfg(64, &mx6qp_ddr_ioregs, &mx6qp_grp_ioregs);
+		spl_dram_init_imx6qp_lpddr3();
+	} else if (is_cpu_type(MXC_CPU_MX6SOLO)) {
+		mx6sdl_dram_iocfg(32, &mx6sdl_ddr_ioregs, &mx6sdl_grp_ioregs);
+		mx6_dram_cfg(&mem_s, &mx6s_512m_mmdc_calib, &h5tq2g63dfr);
+	} else if (is_cpu_type(MXC_CPU_MX6DL)) {
+		mx6sdl_dram_iocfg(64, &mx6sdl_ddr_ioregs, &mx6sdl_grp_ioregs);
+		mx6_dram_cfg(&mem_dl, &mx6dl_1g_mmdc_calib, &h5tq2g63dfr);
+	} else if (is_cpu_type(MXC_CPU_MX6Q)) {
+		mx6dq_dram_iocfg(64, &mx6dq_ddr_ioregs, &mx6dq_grp_ioregs);
+		mx6_dram_cfg(&mem_q, &mx6q_2g_mmdc_calib, &h5t04g63afr);
+	}
+}
+
+void board_init_f(ulong dummy)
+{
+	ccgr_init();
+
+	/* setup AIPS and disable watchdog */
+	arch_cpu_init();
+
+	gpr_init();
+
+	/* iomux */
+	board_early_init_f();
+
+	/* setup GP timer */
+	timer_init();
+
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+
+	/* DDR initialization */
+	spl_dram_init();
+}
+#endif
diff --git a/board/wandboard-custom/wandboard-custom.c b/board/wandboard-custom/wandboard-custom.c
new file mode 100644
index 000000000000..d05914c8fa1e
--- /dev/null
+++ b/board/wandboard-custom/wandboard-custom.c
@@ -0,0 +1,561 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014 O.S. Systems Software LTDA.
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/mach-imx/video.h>
+#include <asm/mach-imx/sata.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <phy.h>
+#include <input.h>
+#include <i2c.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define USDHC1_CD_GPIO		IMX_GPIO_NR(1, 2)
+#define USDHC3_CD_GPIO		IMX_GPIO_NR(3, 9)
+#define ETH_PHY_RESET		IMX_GPIO_NR(3, 29)
+#define ETH_PHY_AR8035_POWER	IMX_GPIO_NR(7, 13)
+#define REV_DETECTION		IMX_GPIO_NR(2, 28)
+
+static bool with_pmic;
+
+int dram_init(void)
+{
+	gd->ram_size = imx_ddr_size();
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	IOMUX_PADS(PAD_CSI0_DAT10__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT11__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	IOMUX_PADS(PAD_SD1_CLK__SD1_CLK    | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_CMD__SD1_CMD    | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DAT0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DAT1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DAT2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DAT3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	/* Carrier MicroSD Card Detect */
+	IOMUX_PADS(PAD_GPIO_2__GPIO1_IO02  | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	IOMUX_PADS(PAD_SD3_CLK__SD3_CLK    | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_CMD__SD3_CMD    | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	/* SOM MicroSD Card Detect */
+	IOMUX_PADS(PAD_EIM_DA9__GPIO3_IO09  | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const enet_pads[] = {
+	IOMUX_PADS(PAD_ENET_MDIO__ENET_MDIO  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_MDC__ENET_MDC    | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TXC__RGMII_TXC  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD0__RGMII_TD0  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD1__RGMII_TD1  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD2__RGMII_TD2  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD3__RGMII_TD3  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TX_CTL__RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_REF_CLK__ENET_TX_CLK  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RXC__RGMII_RXC  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD0__RGMII_RD0  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD1__RGMII_RD1  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD2__RGMII_RD2  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD3__RGMII_RD3  | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RX_CTL__RGMII_RX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	/* AR8031 PHY Reset */
+	IOMUX_PADS(PAD_EIM_D29__GPIO3_IO29    | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const enet_ar8035_power_pads[] = {
+	/* AR8035 POWER */
+	IOMUX_PADS(PAD_GPIO_18__GPIO7_IO13    | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const rev_detection_pad[] = {
+	IOMUX_PADS(PAD_EIM_EB0__GPIO2_IO28  | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static void setup_iomux_uart(void)
+{
+	SETUP_IOMUX_PADS(uart1_pads);
+}
+
+static void setup_iomux_enet(void)
+{
+	SETUP_IOMUX_PADS(enet_pads);
+
+	if (with_pmic) {
+		SETUP_IOMUX_PADS(enet_ar8035_power_pads);
+		/* enable AR8035 POWER */
+		gpio_direction_output(ETH_PHY_AR8035_POWER, 0);
+	}
+	/* wait until 3.3V of PHY and clock become stable */
+	mdelay(10);
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(ETH_PHY_RESET, 0);
+	mdelay(10);
+	gpio_set_value(ETH_PHY_RESET, 1);
+	udelay(100);
+}
+
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC3_BASE_ADDR},
+	{USDHC1_BASE_ADDR},
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	u32 index = 0;
+
+	/*
+	 * Following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    SOM MicroSD
+	 * mmc1                    Carrier board MicroSD
+	 */
+	for (index = 0; index < CONFIG_SYS_FSL_USDHC_NUM; ++index) {
+		switch (index) {
+		case 0:
+			SETUP_IOMUX_PADS(usdhc3_pads);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			usdhc_cfg[0].max_bus_width = 4;
+			gpio_direction_input(USDHC3_CD_GPIO);
+			break;
+		case 1:
+			SETUP_IOMUX_PADS(usdhc1_pads);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			usdhc_cfg[1].max_bus_width = 4;
+			gpio_direction_input(USDHC1_CD_GPIO);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+			       "(%d) then supported by the board (%d)\n",
+			       index + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[index]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int ar8031_phy_fixup(struct phy_device *phydev)
+{
+	unsigned short val;
+	int mask;
+
+	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	if (with_pmic)
+		mask = 0xffe7;	/* AR8035 */
+	else
+		mask = 0xffe3;	/* AR8031 */
+
+	val &= mask;
+	val |= 0x18;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	val |= 0x0100;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	ar8031_phy_fixup(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+struct i2c_pads_info mx6q_i2c2_pad_info = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_KEY_COL3__I2C2_SCL
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_COL3__GPIO4_IO12
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_KEY_ROW3__I2C2_SDA
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_ROW3__GPIO4_IO13
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+
+struct i2c_pads_info mx6dl_i2c2_pad_info = {
+	.scl = {
+		.i2c_mode = MX6DL_PAD_KEY_COL3__I2C2_SCL
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_KEY_COL3__GPIO4_IO12
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6DL_PAD_KEY_ROW3__I2C2_SDA
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_KEY_ROW3__GPIO4_IO13
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+
+struct i2c_pads_info mx6q_i2c3_pad_info = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_GPIO_5__I2C3_SCL
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_GPIO_5__GPIO1_IO05
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 5)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_GPIO_16__I2C3_SDA
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_GPIO_16__GPIO7_IO11
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(7, 11)
+	}
+};
+
+struct i2c_pads_info mx6dl_i2c3_pad_info = {
+	.scl = {
+		.i2c_mode = MX6DL_PAD_GPIO_5__I2C3_SCL
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_GPIO_5__GPIO1_IO05
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 5)
+	},
+	.sda = {
+		.i2c_mode = MX6DL_PAD_GPIO_16__I2C3_SDA
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_GPIO_16__GPIO7_IO11
+			| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(7, 11)
+	}
+};
+
+static iomux_v3_cfg_t const fwadapt_7wvga_pads[] = {
+	IOMUX_PADS(PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK),
+	IOMUX_PADS(PAD_DI0_PIN2__IPU1_DI0_PIN02), /* HSync */
+	IOMUX_PADS(PAD_DI0_PIN3__IPU1_DI0_PIN03), /* VSync */
+	IOMUX_PADS(PAD_DI0_PIN4__IPU1_DI0_PIN04	| MUX_PAD_CTRL(PAD_CTL_DSE_120ohm)), /* Contrast */
+	IOMUX_PADS(PAD_DI0_PIN15__IPU1_DI0_PIN15), /* DISP0_DRDY */
+	IOMUX_PADS(PAD_DISP0_DAT0__IPU1_DISP0_DATA00),
+	IOMUX_PADS(PAD_DISP0_DAT1__IPU1_DISP0_DATA01),
+	IOMUX_PADS(PAD_DISP0_DAT2__IPU1_DISP0_DATA02),
+	IOMUX_PADS(PAD_DISP0_DAT3__IPU1_DISP0_DATA03),
+	IOMUX_PADS(PAD_DISP0_DAT4__IPU1_DISP0_DATA04),
+	IOMUX_PADS(PAD_DISP0_DAT5__IPU1_DISP0_DATA05),
+	IOMUX_PADS(PAD_DISP0_DAT6__IPU1_DISP0_DATA06),
+	IOMUX_PADS(PAD_DISP0_DAT7__IPU1_DISP0_DATA07),
+	IOMUX_PADS(PAD_DISP0_DAT8__IPU1_DISP0_DATA08),
+	IOMUX_PADS(PAD_DISP0_DAT9__IPU1_DISP0_DATA09),
+	IOMUX_PADS(PAD_DISP0_DAT10__IPU1_DISP0_DATA10),
+	IOMUX_PADS(PAD_DISP0_DAT11__IPU1_DISP0_DATA11),
+	IOMUX_PADS(PAD_DISP0_DAT12__IPU1_DISP0_DATA12),
+	IOMUX_PADS(PAD_DISP0_DAT13__IPU1_DISP0_DATA13),
+	IOMUX_PADS(PAD_DISP0_DAT14__IPU1_DISP0_DATA14),
+	IOMUX_PADS(PAD_DISP0_DAT15__IPU1_DISP0_DATA15),
+	IOMUX_PADS(PAD_DISP0_DAT16__IPU1_DISP0_DATA16),
+	IOMUX_PADS(PAD_DISP0_DAT17__IPU1_DISP0_DATA17),
+	IOMUX_PADS(PAD_SD4_DAT2__GPIO2_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL)), /* DISP0_BKLEN */
+	IOMUX_PADS(PAD_SD4_DAT3__GPIO2_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL)), /* DISP0_VDDEN */
+};
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	imx_enable_hdmi_phy();
+}
+
+static int detect_i2c(struct display_info_t const *dev)
+{
+	return (0 == i2c_set_bus_num(dev->bus)) &&
+			(0 == i2c_probe(dev->addr));
+}
+
+static void enable_fwadapt_7wvga(struct display_info_t const *dev)
+{
+	SETUP_IOMUX_PADS(fwadapt_7wvga_pads);
+
+	gpio_direction_output(IMX_GPIO_NR(2, 10), 1);
+	gpio_direction_output(IMX_GPIO_NR(2, 11), 1);
+}
+
+struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= detect_hdmi,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= 1,
+	.addr	= 0x10,
+	.pixfmt	= IPU_PIX_FMT_RGB666,
+	.detect	= detect_i2c,
+	.enable	= enable_fwadapt_7wvga,
+	.mode	= {
+		.name           = "FWBADAPT-LCD-F07A-0102",
+		.refresh        = 60,
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 33260,
+		.left_margin    = 128,
+		.right_margin   = 128,
+		.upper_margin   = 22,
+		.lower_margin   = 22,
+		.hsync_len      = 1,
+		.vsync_len      = 1,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	int reg;
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	/* Disable LCD backlight */
+	SETUP_IOMUX_PAD(PAD_DI0_PIN4__GPIO4_IO20);
+	gpio_direction_input(IMX_GPIO_NR(4, 20));
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+
+	return cpu_eth_init(bis);
+}
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+#ifdef CONFIG_SATA
+	setup_sata();
+#endif
+
+	return 0;
+}
+
+#define PMIC_I2C_BUS		2
+
+int power_init_board(void)
+{
+	struct pmic *p;
+	u32 reg;
+
+	/* configure PFUZE100 PMIC */
+	power_pfuze100_init(PMIC_I2C_BUS);
+	p = pmic_get("PFUZE100");
+	if (p && !pmic_probe(p)) {
+		pmic_reg_read(p, PFUZE100_DEVICEID, &reg);
+		printf("PMIC:  PFUZE100 ID=0x%02x\n", reg);
+		with_pmic = true;
+
+		/* Set VGEN2 to 1.5V and enable */
+		pmic_reg_read(p, PFUZE100_VGEN2VOL, &reg);
+		reg &= ~(LDO_VOL_MASK);
+		reg |= (LDOA_1_50V | (1 << (LDO_EN)));
+		pmic_reg_write(p, PFUZE100_VGEN2VOL, reg);
+	}
+
+	return 0;
+}
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	  MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	  MAKE_CFGVAL(0x40, 0x20, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+static bool is_revc1(void)
+{
+	SETUP_IOMUX_PADS(rev_detection_pad);
+	gpio_direction_input(REV_DETECTION);
+
+	if (gpio_get_value(REV_DETECTION))
+		return true;
+	else
+		return false;
+}
+
+static bool is_revd1(void)
+{
+	if (with_pmic)
+		return true;
+	else
+		return false;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	if (is_mx6dqp())
+		env_set("board_rev", "MX6QP");
+	else if (is_mx6dq())
+		env_set("board_rev", "MX6Q");
+	else
+		env_set("board_rev", "MX6DL");
+
+	if (is_revd1())
+		env_set("board_name", "D1");
+	else if (is_revc1())
+		env_set("board_name", "C1");
+	else
+		env_set("board_name", "B1");
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6dl_i2c2_pad_info);
+	if (is_mx6dq() || is_mx6dqp()) {
+		setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6q_i2c2_pad_info);
+		setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6q_i2c3_pad_info);
+	} else {
+		setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6dl_i2c2_pad_info);
+		setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &mx6dl_i2c3_pad_info);
+	}
+
+	setup_display();
+#endif
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	if (is_revd1())
+		puts("Board: Wandboard Custom rev D1\n");
+	else if (is_revc1())
+		puts("Board: Wandboard Custom rev C1\n");
+	else
+		puts("Board: Wandboard Custom rev B1\n");
+
+	return 0;
+}
diff --git a/configs/wandboard-custom_defconfig b/configs/wandboard-custom_defconfig
new file mode 100644
index 000000000000..5097d3a7a3d9
--- /dev/null
+++ b/configs/wandboard-custom_defconfig
@@ -0,0 +1,40 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_TARGET_WANDBOARD_CUSTOM=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_VIDEO=y
+CONFIG_CMD_HDMIDETECT=y
+CONFIG_SMBIOS_PRODUCT_NAME="wandboard"
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/mach-imx/spl_sd.cfg,MX6QDL"
+# CONFIG_CONSOLE_MUX is not set
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_DISPLAY_BOARDINFO is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SPL=y
+CONFIG_SPL_EXT_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SATA=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_DM=y
+CONFIG_PHYLIB=y
+CONFIG_DM_THERMAL=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff --git a/include/configs/wandboard-custom.h b/include/configs/wandboard-custom.h
new file mode 100644
index 000000000000..68c8e952ef89
--- /dev/null
+++ b/include/configs/wandboard-custom.h
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Wandboard.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <config_distro_defaults.h>
+#include "mx6_common.h"
+
+#include "imx6_spl.h"
+#define CONFIG_DISPLAY_BOARDINFO_LATE
+
+#define CONFIG_MACH_TYPE		MACH_TYPE_WANDBOARD_IMX6
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(10 * SZ_1M)
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* SATA Configs */
+
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	0x10000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 500 * SZ_1M)
+
+/* I2C Configs */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+
+/* MMC Configuration */
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+/* USB Configs */
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS		0
+
+/* Ethernet Configuration */
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#define CONFIG_ETHPRIME			"FEC"
+#define CONFIG_FEC_MXC_PHYADDR		1
+#define CONFIG_PHY_ATHEROS
+
+/* Framebuffer */
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_HDMI
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"console=ttymxc0,115200\0" \
+	"splashpos=m,m\0" \
+	"fdtfile=undefined\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_addr_r=0x18000000\0" \
+	"fdt_addr=0x18000000\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
+	"finduuid=part uuid mmc 0:1 uuid\0" \
+	"update_sd_firmware_filename=u-boot.imx\0" \
+	"update_sd_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if mmc dev ${mmcdev}; then "	\
+			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "	\
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+			"fi; "	\
+		"fi\0" \
+	"findfdt="\
+		"if test $board_name = D1 && test $board_rev = MX6QP ; then " \
+			"setenv fdtfile imx6qp-wandboard-custom-revd1.dtb; fi; " \
+		"if test $board_name = D1 && test $board_rev = MX6Q ; then " \
+			"setenv fdtfile imx6q-wandboard-custom-revd1.dtb; fi; " \
+		"if test $board_name = D1 && test $board_rev = MX6DL ; then " \
+			"setenv fdtfile imx6dl-wandboard-custom-revd1.dtb; fi; " \
+		"if test $board_name = C1 && test $board_rev = MX6Q ; then " \
+			"setenv fdtfile imx6q-wandboard-custom.dtb; fi; " \
+		"if test $board_name = C1 && test $board_rev = MX6DL ; then " \
+			"setenv fdtfile imx6dl-wandboard-custom.dtb; fi; " \
+		"if test $board_name = B1 && test $board_rev = MX6Q ; then " \
+			"setenv fdtfile imx6q-wandboard-custom-revb1.dtb; fi; " \
+		"if test $board_name = B1 && test $board_rev = MX6DL ; then " \
+			"setenv fdtfile imx6dl-wandboard-custom-revb1.dtb; fi; " \
+		"if test $fdtfile = undefined; then " \
+			"echo WARNING: Could not determine dtb to use; fi; \0" \
+	"kernel_addr_r=" __stringify(CONFIG_LOADADDR) "\0" \
+	"pxefile_addr_r=" __stringify(CONFIG_LOADADDR) "\0" \
+	"ramdisk_addr_r=0x13000000\0" \
+	"ramdiskaddr=0x13000000\0" \
+	"scriptaddr=" __stringify(CONFIG_LOADADDR) "\0" \
+	BOOTENV
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(MMC, mmc, 0) \
+	func(MMC, mmc, 1) \
+	func(SATA, sata, 0) \
+	func(USB, usb, 0) \
+	func(PXE, pxe, na) \
+	func(DHCP, dhcp, na)
+
+#define CONFIG_BOOTCOMMAND \
+	   "run findfdt; " \
+	   "run finduuid; " \
+	   "run distro_bootcmd"
+
+#include <config_distro_bootcmd.h>
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* Environment organization */
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+
+#endif			       /* __CONFIG_H * */
